From e84e5fd69565cf806b2d6d209c5e89ef3d6e6ffd Mon Sep 17 00:00:00 2001
From: Tamas K Lengyel <tamas.lengyel@intel.com>
Date: Tue, 27 Oct 2020 19:18:53 -0400
Subject: [PATCH] KF/x integration patch (3.0c)

---
 include/config.h     |  4 ++++
 include/forkserver.h |  2 ++
 src/afl-forkserver.c | 24 ++++++++++++++++--------
 src/afl-fuzz-state.c |  4 ++--
 src/afl-fuzz.c       | 18 ++++++++++++++----
 5 files changed, 38 insertions(+), 14 deletions(-)

diff --git a/include/config.h b/include/config.h
index 93249ed9..ddb64e71 100644
--- a/include/config.h
+++ b/include/config.h
@@ -86,6 +86,10 @@
 
 #define MEM_LIMIT_UNICORN 0
 
+/* Default memory limit when running in Xen mode (MB): */
+
+#define MEM_LIMIT_XEN 750
+
 /* Number of calibration cycles per every new test case (and for test
    cases that show variable behavior): */
 
diff --git a/include/forkserver.h b/include/forkserver.h
index 5d5c728f..4653ca8a 100644
--- a/include/forkserver.h
+++ b/include/forkserver.h
@@ -86,6 +86,8 @@ typedef struct afl_forkserver {
   bool uses_crash_exitcode;             /* Custom crash exitcode specified? */
   u8   crash_exitcode;                  /* The crash exitcode specified     */
 
+  u8 xen_mode;                          /* if running in qemu mode or not   */
+
   u32 *shmem_fuzz_len;                  /* length of the fuzzing test case  */
 
   u8 *shmem_fuzz;                       /* allocated memory for fuzzing     */
diff --git a/src/afl-forkserver.c b/src/afl-forkserver.c
index 3afb94be..790d1e46 100644
--- a/src/afl-forkserver.c
+++ b/src/afl-forkserver.c
@@ -559,12 +559,12 @@ void afl_fsrv_start(afl_forkserver_t *fsrv, char **argv,
 
     if (!time_ms) {
 
-      kill(fsrv->fsrv_pid, SIGKILL);
+      kill(fsrv->fsrv_pid, fsrv->xen_mode ? SIGTERM : SIGKILL);
 
     } else if (time_ms > fsrv->init_tmout) {
 
       fsrv->last_run_timed_out = 1;
-      kill(fsrv->fsrv_pid, SIGKILL);
+      kill(fsrv->fsrv_pid, fsrv->xen_mode ? SIGTERM : SIGKILL);
 
     } else {
 
@@ -944,10 +944,10 @@ void afl_fsrv_start(afl_forkserver_t *fsrv, char **argv,
 
 static void afl_fsrv_kill(afl_forkserver_t *fsrv) {
 
-  if (fsrv->child_pid > 0) { kill(fsrv->child_pid, SIGKILL); }
+  if (fsrv->child_pid > 0 && !fsrv->xen_mode ) { kill(fsrv->child_pid, SIGKILL); }
   if (fsrv->fsrv_pid > 0) {
 
-    kill(fsrv->fsrv_pid, SIGKILL);
+    kill(fsrv->fsrv_pid, fsrv->xen_mode ? SIGTERM : SIGKILL);
     if (waitpid(fsrv->fsrv_pid, NULL, 0) <= 0) { WARNF("error waitpid\n"); }
 
   }
@@ -1088,13 +1088,16 @@ fsrv_run_result_t afl_fsrv_run_target(afl_forkserver_t *fsrv, u32 timeout,
 
   if (exec_ms > timeout) {
 
+    fsrv->last_run_timed_out = 1;
+
     /* If there was no response from forkserver after timeout seconds,
     we kill the child. The forkserver should inform us afterwards */
 
-    kill(fsrv->child_pid, SIGKILL);
-    fsrv->last_run_timed_out = 1;
+    if ( fsrv->xen_mode )
+        kill(fsrv->fsrv_pid, SIGTERM);
+    else
+        kill(fsrv->child_pid, SIGKILL);
     if (read(fsrv->fsrv_st_fd, &fsrv->child_status, 4) < 4) { exec_ms = 0; }
-
   }
 
   if (!exec_ms) {
@@ -1137,7 +1140,12 @@ fsrv_run_result_t afl_fsrv_run_target(afl_forkserver_t *fsrv, u32 timeout,
 
   /* Report outcome to caller. */
 
-  if (WIFSIGNALED(fsrv->child_status) && !*stop_soon_p) {
+  if (fsrv->xen_mode && !*stop_soon_p && fsrv->last_run_timed_out)
+  {
+    return FSRV_RUN_TMOUT;
+  }
+
+  if (!fsrv->xen_mode && WIFSIGNALED(fsrv->child_status) && !*stop_soon_p) {
 
     fsrv->last_kill_signal = WTERMSIG(fsrv->child_status);
 
diff --git a/src/afl-fuzz-state.c b/src/afl-fuzz-state.c
index 9c51a3ef..905b4885 100644
--- a/src/afl-fuzz-state.c
+++ b/src/afl-fuzz-state.c
@@ -507,8 +507,8 @@ void afl_states_stop(void) {
 
   LIST_FOREACH(&afl_states, afl_state_t, {
 
-    if (el->fsrv.child_pid > 0) kill(el->fsrv.child_pid, SIGKILL);
-    if (el->fsrv.fsrv_pid > 0) kill(el->fsrv.fsrv_pid, SIGKILL);
+    if (el->fsrv.child_pid > 0) kill(el->fsrv.child_pid, SIGTERM);
+    if (el->fsrv.fsrv_pid > 0) kill(el->fsrv.fsrv_pid, SIGTERM);
 
   });
 
diff --git a/src/afl-fuzz.c b/src/afl-fuzz.c
index 391d4c4f..64d161fb 100644
--- a/src/afl-fuzz.c
+++ b/src/afl-fuzz.c
@@ -76,8 +76,8 @@ static void at_exit() {
 
   }
 
-  if (pid1 > 0) { kill(pid1, SIGKILL); }
-  if (pid2 > 0) { kill(pid2, SIGKILL); }
+  if (pid1 > 0) { kill(pid1, SIGTERM); }
+  if (pid2 > 0) { kill(pid2, SIGTERM); }
 
 }
 
@@ -104,7 +104,8 @@ static void usage(u8 *argv0, int more_help) {
       "  -Q            - use binary-only instrumentation (QEMU mode)\n"
       "  -U            - use unicorn-based instrumentation (Unicorn mode)\n"
       "  -W            - use qemu-based instrumentation with Wine (Wine "
-      "mode)\n\n"
+      "mode)\n"
+      "  -X            - use virtual-machine instrumentation (Xen mode)\n\n"
 
       "Mutator settings:\n"
       "  -D            - enable deterministic fuzzing (once per queue entry)\n"
@@ -326,7 +327,7 @@ int main(int argc, char **argv_orig, char **envp) {
 
   while ((opt = getopt(
               argc, argv,
-              "+b:c:i:I:o:f:F:m:t:T:dDnCB:S:M:x:QNUWe:p:s:V:E:L:hRP:Z")) > 0) {
+              "+b:c:i:I:o:f:F:m:t:T:dDnCB:S:M:x:QNUWe:p:s:V:E:L:hRP:ZX")) > 0) {
 
     switch (opt) {
 
@@ -723,6 +724,15 @@ int main(int argc, char **argv_orig, char **envp) {
 
         break;
 
+      case 'X':                                                /* Xen mode */
+
+        if (afl->fsrv.xen_mode) { FATAL("Multiple -X options not supported"); }
+        afl->fsrv.xen_mode = 1;
+
+        if (!mem_limit_given) { afl->fsrv.mem_limit = MEM_LIMIT_XEN; }
+
+        break;
+
       case 'W':                                           /* Wine+QEMU mode */
 
         if (afl->use_wine) { FATAL("Multiple -W options not supported"); }
-- 
2.29.2

